#include <iostream>
#include <bits/stdc++.h>
using namespace std;

void passByPointer(int *n, int *m){
    int t = *n;
    *n = *m;
    *m = t;
}

void passByValue(int n, int m){
    int t = n;
    n = m;
    m = t;
}

void passByReference(int &a, int &b){
    int t = a;
    a = b;
    b = t;
}

int main() {
    // int a = 50;
    // int * n = &a;
    // int ** m = &n;

    // cout<<a<<endl; // 50
    // cout<<&a<<endl; // address of a 
    // cout<<n<<endl; // address of a
    // cout<<&n<<endl; // address of pointer 1
    // cout<<*n<<endl; //  50
    // cout<<m<<endl; // address of pointer 1
    // cout<<*m<<endl; // address of a

    // Dynamic Memory Allocation

    int y;
    cin>>y;
    int *d = new int[y];
    int g[12];

    for(int i=0;i<y;i++){
        d[i] = i;
    }

    for(int i=0;i<y;i++){
        cout<<d[i]<<" ";   
    }
    cout<<endl<<"Size of array = "<<sizeof(g)/sizeof(g[0]);
    cout<<endl<<"Size of array = "<<sizeof(d)/sizeof(d[0]);

    int n = 9, m = 6;

    // Pass By pointer
    cout<<endl<<n<<" "<<m<<endl;
    passByPointer(&n, &m);
    cout<<n<<" "<<m<<endl;

    // Pass by Value
    cout<<n<<" "<<m<<endl;
    passByValue(n, m);
    cout<<n<<" "<<m<<endl;

    // Pass by Reference
    cout<<n<<" "<<m<<endl;
    passByReference(n, m);
    cout<<n<<" "<<m<<endl;
    
    // always initialize a pointer with some address or 0(NULL pointer) or its harmful
    int *p;
    cout<<*p<<endl;
    (*p)++;
    
    //increment and decrement in pointers only makes sense in case of arrays in which each memory block is next to each other
    
    //generally all variables are created in the stack section/static section because they are resolved at the compile time
    // but we can algo create variables in the HEAP section/ dynamic section if we don't know the size of the array or variable at the compile time, in HEAP section memory
    // can be allocated at the run time
    
    // STATIC -> memory is released after the scope ends
    // DYNAMIC -> memory must be released manually
    
    int *p = new int;
    delete p;
    
    int *p = new int[40];
    delete [] p;
    
    return 0;
}
