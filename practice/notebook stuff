// Mid Element

int midElement(Node *head) {
    Node *slow = head;
    Node *fast = head;
    while (fast -> next != NULL && fast -> next -> next != NULL) {
        slow = slow -> next;
        fast = fast -> next -> next;
    }
    return slow -> data;
}

// Reverse of a linked list

Node *reverseLL(Node *head) {
    Node *prev = NULL;
    Node *curr = head;
    Node *forw = NULL;
    while (curr != NULL) {
        forw = curr -> next;
        curr -> next = prev;
        prev = curr;
        curr = forw;
    }
    return prev;
}

// is Palindrome

bool isPalindrome(Node *head) {
    Node *mid = midElement(head);
    Node *nHead = reverseLL(mid -> next);
    mid -> next = NULL;
    while (nHead != NULL) {
        if (head -> data != nHead -> data) {
            return false;
        }
        nHead = nHead -> next;
        head = head -> next;
    }
    return true;
}

// fold a LL

Node *foldLL(Node *head) {
    Node *mid = midElement(head);
    Node *newHead = reverseLL(mid -> next);
    mid -> next = NULL;
    Node *h1 = head;
    Node *h2 = newHead;
    Node *forw1 = NULL;
    Node *forw2 = NULL;
    while (h2 != NULL) {
        forw1 = h1 -> next;
        forw2 = h2 -> next;
        h1 -> next = h2;
        h2 -> next = forw1;
        h1 = forw1;
        h2 = forw2;
    }
    return head;
}

//unfold a LL

Node *unfoldLL(Node *head) {
    Node *h1 = head;
    Node *h2 = head -> next;
    Node *nHead = h2;
    Node *forw = NULL;
    while (h2 != NULL && h2 -> next != NULL) {
        forw = h2 -> next;
        h1 -> next = forw;
        h2 -> next = forw -> next;
        h1 = forw;
        h2 = forw -> next;
    }
    h1 -> next = NULL;
    nHead = reverseLL(nHead);
    h1 -> next = nHead;
    return head;
}

// merge 2 sorted LL

Node *mergeTwoSortedLL(Node *head1, Node *head2) {
    Node *dummy = new Node(-1);
    Node *h1 = head1;
    Node *h2 = head2;
    Node *prev = dummy;
    while (h1 != NULL && h2 != NULL) {
        if (h1 -> data < h2 -> data) {
            prev -> next = h1;
            prev = h1;
            h1 = h1 -> next;
        } else {
            prev -> next = h2;
            prev = h2;
            h2 = h2 -> next;
        }
    }
    prev -> next = h1 != NULL ? h1 : h2;
    return dummy -> next;
}

// merge k sorted linked list

Node *mergeKsortedLL(vector<Node *> lists, int s, int e) {
    if (s >= e)
        return lists[s];
    int mid = (s + e) / 2;
    Node *list1 = mergeKsortedLL(lists, s, mid);
    Node *list2 = mergeKsortedLL(lists, mid + 1, e);
    Node *nHead = mergeTwoSortedLL(list1, list2);
    return nHead;
}

// mergesort

Node *mergeSort(Node *head) {
    if (head == NULL || head -> next == NULL) return head;

    Node *mid = midElement(head);
    Node *nHead = mid -> next;
    mid -> next = NULL;

    Node *l1 = mergeSort(head);
    Node *l2 = mergeSort(nHead);
    return mergeTwoSortedLL(l1, l2);
}

// Path sum

int pathSum(BinaryTreeNode *root, int currSum, int targetSum) {
     if (root == NULL) return 0;
    int count = 0;
    currSum += root -> val;
    if (freq[currSum - targetSum])
        count+=freq[currSum - targetSum];
    freq[currSum]++;
    int p1 = pathSum(root -> left, currSum, targetSum);
    int p2 = pathSum(root -> right, currSum, targetSum);
    freq[currSum]--;
    return p1 + p2 + count;
}

// print Left View

void printLeftView(BinaryTreeNode *root) {
    queue<BinaryTreeNode *> q;
    q.push(root);
    while (!q.empty()) {
        int size = q.size();
        cout << q.front() -> data << endl;
        while (size--) {
            BinaryTreeNode *curr = q.front();
            q.pop();
            if (curr -> left != NULL) {
                q.push(curr -> left);
            }
            if (curr -> right != NULL) {
                q.push(curr -> right);
            }
        }
    }
}

//print right view 

void printLeftView(BinaryTreeNode *root) {
    queue<BinaryTreeNode *> q;
    q.push(root);
    while (!q.empty()) {
        int size = q.size();
        cout << q.front() -> data << endl;
        while (size--) {
            BinaryTreeNode *curr = q.front();
            q.pop();
            if (curr -> right != NULL) {
                q.push(curr -> right);
            }
            if (curr -> left != NULL) {
                q.push(curr -> left);
            }
        }
    }
}

// Width of binary tree

int mm[2] = {0, 0};

void widthOfBT(BinaryTreeNode *root, int hl) {
    if (root == NULL) return;

    mm[0] = min(mm[0], hl);
    mm[1] = max(mm[1], hl);
    widthOfBT(root -> left, hl - 1);
    widthOfBT(root -> right, hl + 1);
}

// vertical Order of binary tree

void verticalOrderTraversal(BinaryTreeNode *root, int hl) {
    queue<pair<BinaryTreeNode *, int>> q;
    q.push({ root, hl });
    while (!q.empty()) {
        int size = q.size();
        while (size--) {
            pair<BinaryTreeNode *, int> curr = q.front();
            q.pop();
            int hl = curr.second;
            mp[hl].push_back(curr.first -> data);
            if (curr.first -> left != NULL) {
                q.push({ curr.first -> left, hl - 1 });
            }
            if (curr.first -> right != NULL) {
                q.push({ curr.first -> right, hl + 1 });
            }
        }
    }
}

for (auto list : mp) {
        cout << list.first << " : ";
        for (int l : list.second)
            cout << l << " ";
        cout << endl;
    }